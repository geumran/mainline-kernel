page owner: Tracking about who allocated each page
page owner: 각 페이지의 소유자 추적하기
-----------------------------------------------------------

* Introduction
* 도입부

page owner is for the tracking about who allocated each page.
It can be used to debug memory leak or to find a memory hogger.
When allocation happens, information about allocation such as call stack
and order of pages is stored into certain storage for each page.
When we need to know about status of all pages, we can get and analyze
this information.
page owner는 각 페이지를 누가 할당했는지 추적하는 기능이다. 이 기능은 메모리 누수를 디버그하거나 메모리 hogger를 찾는 데 사용할 수 있다. 페이지 할당이 발생하면 호출 스택 및 페이지의 order정보와 같은 할당 정보가 각 페이지의 특정 장소에 저장된다. 모든 페이지의 상태를 알아야 할 때 이 정보를 통해 분석 할 수 있다.

Although we already have tracepoint for tracing page allocation/free,
using it for analyzing who allocate each page is rather complex. We need
to enlarge the trace buffer for preventing overlapping until userspace
program launched. And, launched program continually dump out the trace
buffer for later analysis and it would change system behviour with more
possibility rather than just keeping it in memory, so bad for debugging.
우리는 이미 페이지 할당/해제를 추적하는 tracepoint를 가지고 있지만 각 페이지를 할당하는 owner를 분석하기 위해 이를 사용하는 것은 다소 복잡하다. 사용자 공간 프로그램이 시작될 때까지 중복을 방지하기 위해 trace buffer를 확대해야하다. 또한 실행 된 프로그램은 추후 분석을 위해 trace buffer를 계속해서 덤프하므로 메모리를 유지하는 것보다 디버깅에 좋지 않은 가능성으로 시스템 동작을 변경하다.

page owner can also be used for various purposes. For example, accurate
fragmentation statistics can be obtained through gfp flag information of
each page. It is already implemented and activated if page owner is
enabled. Other usages are more than welcome.
page owner는 다양한 용도로 사용될 수 있다. 예를 들어, 각 페이지의 gfp 플래그 정보를 통해 정확한 fragmentation 통계를 얻을 수 있다. page owner가 활성화 된 경우 이미 구현되고 활성화된다. 다른 용도로 사용하는것도 환영한다.

page owner is disabled in default. So, if you'd like to use it, you need
to add "page_owner=on" into your boot cmdline. If the kernel is built
with page owner and page owner is disabled in runtime due to no enabling
boot option, runtime overhead is marginal. If disabled in runtime, it
doesn't require memory to store owner information, so there is no runtime
memory overhead. And, page owner inserts just two unlikely branches into
the page allocator hotpath and if not enabled, then allocation is done
like as the kernel without page owner. These two unlikely branches should
not affect to allocation performance, especially if the static keys jump
label patching functionality is available. Following is the kernel's code
size change due to this facility.
page owner는 기본적으로 사용이 비활성화되어 있다. 따라서, page owner를 사용하고 싶다면 "page_owner=on"을 부팅 cmdline에 추가해야 한다. 커널이 page owner로 빌드되고 실행 가능 부팅 옵션이 없기 때문에 page owner가 런타임에 비활성화 된 경우 런타임 오버 헤드가 거의 없습니다. 런타임에 사용하지 않도록 설정하면 소유자 정보를 저장하는 데 메모리가 필요하지 않으므로 런타임 메모리 오버 헤드가 없습니다. 그리고 page owner는 페이지 할당 자 핫 패스에 두 개의 가능성이 적은 브랜치를 삽입하고, 활성화되지 않은 경우 page owner가없는 커널처럼 할당을 수행하다. 정적 키 점프 레이블 패치 기능을 사용할 수있는 경우 특히이 두 가지 가지가 할당 성능에 영향을 미치지 않습니다. 다음은이 기능으로 인한 커널의 코드 크기 변경입니다.

- Without page owner
   text    data     bss     dec     hex filename
  40662    1493     644   42799    a72f mm/page_alloc.o

- With page owner
   text    data     bss     dec     hex filename
  40892    1493     644   43029    a815 mm/page_alloc.o
   1427      24       8    1459     5b3 mm/page_ext.o
   2722      50       0    2772     ad4 mm/page_owner.o

Although, roughly, 4 KB code is added in total, page_alloc.o increase by
230 bytes and only half of it is in hotpath. Building the kernel with
page owner and turning it on if needed would be great option to debug
kernel memory problem.
대략 4KB 코드가 합계로 추가되지만, page_alloc.o는 230 바이트 씩 증가하며 그 중 절반만이 핫 패스에 있다. page owner가있는 커널을 빌드하고 필요하다면 커널을 켜면 커널 메모리 문제를 디버그하는 데 아주 좋습니다.

There is one notice that is caused by implementation detail. page owner
stores information into the memory from struct page extension. This memory
is initialized some time later than that page allocator starts in sparse
memory system, so, until initialization, many pages can be allocated and
they would have no owner information. To fix it up, these early allocated
pages are investigated and marked as allocated in initialization phase.
Although it doesn't mean that they have the right owner information,
at least, we can tell whether the page is allocated or not,
more accurately. On 2GB memory x86-64 VM box, 13343 early allocated pages
are catched and marked, although they are mostly allocated from struct
page extension feature. Anyway, after that, no page is left in
un-tracking state.
구현 세부 사항으로 인해 하나의 통지가 있다. page owner는 struct page extension으로부터 정보를 메모리에 저장하다. 이 메모리는 페이지 할당자가 애매한 메모리 시스템에서 시작하는 것보다 약간 나중에 초기화되므로 초기화 할 때까지 많은 페이지를 할당 할 수 있으며 소유자 정보가 없습니다. 이를 해결하기 위해 초기 할당 페이지를 조사하고 초기화 단계에서 할당 된 것으로 표시하다. 페이지가 할당되었는지 아닌지를 정확하게 알 수 있다. 올바른 소유자 정보가 있음을 의미하지는 않습니다. 2GB 메모리의 x86-64 VM 상자에서 13343 초기 할당 페이지는 주로 구조체 페이지 확장 기능에서 할당되지만 초기에 할당되고 표시된다. 어쨌든, 그 후에는 추적 할 수없는 상태로 남아있는 페이지가 없습니다.

* Usage

1) Build user-space helper
	cd tools/vm
	make page_owner_sort

2) Enable page owner
	Add "page_owner=on" to boot cmdline.

3) Do the job what you want to debug

4) Analyze information from page owner
	cat /sys/kernel/debug/page_owner > page_owner_full.txt
	grep -v ^PFN page_owner_full.txt > page_owner.txt
	./page_owner_sort page_owner.txt sorted_page_owner.txt

	See the result about who allocated each page
	in the sorted_page_owner.txt.
